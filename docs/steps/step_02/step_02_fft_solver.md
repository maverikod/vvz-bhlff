# Step 02: Ядро FFT решателя для фракционного оператора Рисса

## Цель
Реализовать высокоточный спектральный решатель для фракционного оператора Рисса в 3D периодической области.

## Математическая основа

### Фракционный оператор Рисса
```
L_β a = μ(-Δ)^β a + λa
```
где:
- μ > 0 - коэффициент диффузии
- β ∈ (0,2) - фракционный порядок
- λ ≥ 0 - параметр затухания
- (-Δ)^β - фракционный лапласиан

### Спектральная форма
В k-пространстве:
```
â(k) = ŝ(k) / (μ|k|^(2β) + λ)
```

## Основные компоненты

### 1. FFT Solver (core/fft_solver.py)
- Класс `FFTSolver3D` для решения стационарных задач
- Поддержка различных типов источников
- Обработка граничных условий
- Валидация входных данных

### 2. Фракционный лапласиан (core/frac_laplacian.py)
- Класс `FractionalLaplacian` для вычисления (-Δ)^β
- Оптимизированные алгоритмы для различных β
- Кэширование спектральных коэффициентов
- Обработка особых случаев (k=0)

### 3. Временные интеграторы (core/time_integrators.py)
- Класс `TimeIntegrator` для динамических задач
- Поддержка различных схем (CN, экспоненциальная)
- Адаптивный выбор шага по времени
- Контроль устойчивости

## Ключевые особенности

### 1. Точность вычислений
- Использование float64 для всех вычислений
- Строгая нормировка FFT
- Контроль численных ошибок
- Валидация результатов

### 2. Производительность
- Оптимизированные FFT планы
- Векторизованные операции
- Кэширование промежуточных результатов
- Поддержка параллельных вычислений

### 3. Обработка особых случаев
- Корректная обработка k=0 моды
- Валидация условия λ=0 при ŝ(0)≠0
- Обработка граничных случаев β→0, β→2

## Интерфейс

### Основной класс FFT решателя
```python
class FFTSolver3D:
    def __init__(self, domain_size, grid_size, physics_params):
        """Инициализация решателя"""
        
    def solve_stationary(self, source_field):
        """Решение стационарной задачи"""
        
    def solve_time_dependent(self, source_field, time_params):
        """Решение временной задачи"""
        
    def get_spectral_coefficients(self):
        """Получение спектральных коэффициентов"""
        
    def validate_solution(self, solution, source):
        """Валидация решения"""
```

### Конфигурация
```json
{
    "domain": {"L": 1.0, "N": 256},
    "physics": {"mu": 1.0, "beta": 1.0, "lambda": 0.0},
    "solver": {"precision": "float64", "fft_plan": "MEASURE"}
}
```

## Тесты и валидация

### 1. Аналитические тесты
- Плоская волна с известным решением
- Многочастотные источники
- Проверка суперпозиции

### 2. Численные тесты
- Сходимость по сетке
- Энергетический баланс
- Инвариантность к масштабу

### 3. Граничные случаи
- λ=0 с ŝ(0)=0
- λ=0 с ŝ(0)≠0 (должна быть ошибка)
- β→0, β→2

## Критерии готовности
- [ ] Реализован класс FFTSolver3D
- [ ] Реализован FractionalLaplacian
- [ ] Реализованы временные интеграторы
- [ ] Все аналитические тесты проходят
- [ ] Численные тесты показывают правильную сходимость
- [ ] Обработка особых случаев работает корректно
- [ ] Документация и примеры созданы
- [ ] Производительность соответствует требованиям

## Следующий шаг
Step 03: Создание временных интеграторов для динамических задач
