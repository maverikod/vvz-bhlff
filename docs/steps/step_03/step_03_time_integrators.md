# Step 03: Временные интеграторы для динамических задач

## Цель
Реализовать высокоточные временные интеграторы для решения динамических задач фракционного оператора Рисса.

## Математическая основа

### Динамическое уравнение
```
∂a/∂t + ν(-Δ)^β a + λa = s(x,t)
```
где:
- ν > 0 - коэффициент диффузии
- β ∈ (0,2) - фракционный порядок
- λ ≥ 0 - параметр затухания
- s(x,t) - источник

### Спектральная форма
В k-пространстве:
```
∂â/∂t + (ν|k|^(2β) + λ)â = ŝ(k,t)
```

## Основные компоненты

### 1. Базовый класс TimeIntegrator (core/time_integrators.py)
- Абстрактный базовый класс для всех интеграторов
- Общий интерфейс для временного интегрирования
- Система контроля ошибок и валидации
- Поддержка различных схем

### 2. Экспоненциальный интегратор
- Класс `ExponentialIntegrator` для точного решения
- Аналитическое решение для гармонических источников
- Оптимальная точность для линейных задач
- Поддержка адаптивного шага

### 3. Crank-Nicolson интегратор
- Класс `CrankNicolsonIntegrator` для нелинейных задач
- Второй порядок точности по времени
- Безусловная устойчивость
- Эффективная реализация через FFT

### 4. Адаптивный интегратор
- Класс `AdaptiveIntegrator` с контролем ошибки
- Автоматический выбор шага по времени
- Контроль устойчивости
- Оптимизация производительности

## Ключевые особенности

### 1. Точность
- Контроль локальной и глобальной ошибки
- Адаптивный выбор шага
- Валидация результатов
- Сравнение с аналитическими решениями

### 2. Устойчивость
- Анализ устойчивости для различных β
- Контроль CFL условий
- Обработка жестких систем
- Предотвращение численных неустойчивостей

### 3. Производительность
- Оптимизированные алгоритмы
- Векторизованные операции
- Кэширование промежуточных результатов
- Параллельные вычисления

## Интерфейс

### Основной класс интегратора
```python
class TimeIntegrator:
    def __init__(self, domain, physics_params, time_params):
        """Инициализация интегратора"""
        
    def integrate(self, initial_field, source_field, time_range):
        """Временное интегрирование"""
        
    def get_time_step(self):
        """Получение текущего шага по времени"""
        
    def set_time_step(self, dt):
        """Установка шага по времени"""
        
    def validate_stability(self):
        """Проверка устойчивости"""
```

### Конфигурация
```json
{
    "time": {
        "dt": 1e-3,
        "T": 1.0,
        "scheme": "exponential",
        "adaptive": true,
        "tolerance": 1e-8
    }
}
```

## Алгоритмы

### 1. Экспоненциальная схема
Для гармонического источника s(x,t) = s₀(x)e^(-iωt):
```
â(k,t) = â₀(k)e^(-(ν|k|^(2β)+λ)t) + ŝ₀(k)/(ν|k|^(2β)+λ+iω)(1-e^(-(ν|k|^(2β)+λ+iω)t))
```

### 2. Crank-Nicolson схема
```
(â^(n+1) - â^n)/dt + (ν|k|^(2β) + λ)(â^(n+1) + â^n)/2 = (ŝ^(n+1) + ŝ^n)/2
```

### 3. Адаптивная схема
- Оценка локальной ошибки
- Автоматический выбор шага
- Контроль устойчивости
- Оптимизация производительности

## Тесты и валидация

### 1. Аналитические тесты
- Гармонический источник с известным решением
- Экспоненциальное затухание
- Проверка установившегося режима

### 2. Численные тесты
- Сходимость по времени
- Сохранение энергии
- Устойчивость при больших шагах

### 3. Граничные случаи
- β→0 (обычная диффузия)
- β→2 (волновое уравнение)
- λ=0 (консервативная система)

## Критерии готовности
- [ ] Реализован базовый класс TimeIntegrator
- [ ] Реализован ExponentialIntegrator
- [ ] Реализован CrankNicolsonIntegrator
- [ ] Реализован AdaptiveIntegrator
- [ ] Все аналитические тесты проходят
- [ ] Численные тесты показывают правильную сходимость
- [ ] Адаптивный контроль ошибки работает
- [ ] Документация и примеры созданы
- [ ] Производительность соответствует требованиям

## Следующий шаг
Step 04: Реализация валидационных тестов уровня A (базовые решатели)
